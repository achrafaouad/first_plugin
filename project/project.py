# -*- coding: utf-8 -*-
"""
/***************************************************************************
 project
                                 A QGIS plugin
 project
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-06-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by achrafaouad
        email                : achrafaouad7@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5.QtWidgets import QAction, QMessageBox
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QFileDialog ,QMessageBox
from pathlib import Path
from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsFields,
    QgsField,
    QgsGeometry,
    QgsFeature,
    Qgis,
    QgsVectorDataProvider,
)
import random
import string
import csv
import processing
from qgis.analysis import *
from PyQt5.QtCore import *
from qgis.core import *
from qgis.utils import iface
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .project_dialog import projectDialog
import os.path



class MyTableModel(QAbstractTableModel):

    def __init__(self, datain, parent=None):
        QAbstractTableModel.__init__(self, parent)
        self.arraydata = datain

    def rowCount(self, parent):
        return len(self.arraydata)

    def columnCount(self, parent):
        return len(self.arraydata[0])

    def data(self, index, role):
        if not index.isValid():
            return QVariant()
        elif role == Qt.EditRole:
            print("edit mode")
            return None
        elif role != Qt.DisplayRole:
            return None
        return self.arraydata[index.row()][index.column()]

class project:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.lista = []
        self.list1 = []
        self.prive = 0
        self.foret = 0
        self.indice = 0
        self.surface = 0
        self.derogation = 0
        self.val = 0
        self.fn=""
        self.vlayer = 1
        self.name=""
        self.decision = "Favorable"
        self.listOfLayers=[]
        self.listTemp=[]
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'project_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&project')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('project', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/project/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&project'),
                action)
            self.iface.removeToolBarIcon(action)

    def setValue(self):
        index = self.dlg.comboBox_intersect_layers.currentIndex()
        self.vlayer = self.listTemp[index]

        #vlayer = QgsVectorLayer(r"C:\Users\hp\Desktop\Geoinformation_4\Mr_Yazidi\TP\TP_Derogation\SHP_mini_Projet\DOMAINE_COMMUNAL.shp", "DOMAINE_COMMUNAL.shp", "ogr")
        names=[]
        for field in self.vlayer.fields():
            names.append(field.name())

        my_array=[]
        my_array.append(names)
        for feature in self.vlayer.getFeatures():
            list = [j for j in feature.attributes()]
            my_array.append(list)

        tablemodel = MyTableModel(my_array)
        tableview = self.dlg.tableView
        tableview.setModel(tablemodel)

    def table_attribute(self):
        self.lista.clear()
        for i in self.listTemp:
            self.lista.append(i.name())
        self.dlg.comboBox_intersect_layers.clear()
        self.dlg.comboBox_intersect_layers.addItems(self.lista)

    def export(self):
        
        
        csvfile = str(Path(__file__).parent.absolute())+"\\resultat.csv"
        print(csvfile)
        print("*************************************"*10)
        with open(csvfile, "w") as output:
            writer = csv.writer(output, delimiter=';')
            writer.writerows(self.vlayer.getFeatures())
        QMessageBox.information(None, "success", 
        """
        le fichier a éte bien exporté sous le nom resultat.csv
        """+"\nsous le chemin: " + csvfile)
            
                
        
    def export_pdf(self):
        layers = QgsProject.instance().mapLayersByName('DOMAINE_PUBLIC')
        layers1 = QgsProject.instance().mapLayersByName('DOMAINE_FORESTIER')
        layer=layers[0]
        layer1=layers1[0]
        project=QgsProject.instance()
        manager=project.layoutManager()
        layoutName="soufiane"
        #remove any duplicated layouts
        layout_list=manager.printLayouts()
        for layout in layout_list:
            if layout.name() == layoutName:
                manager.removeLayout(layout)

        #add a new layout

        layout=QgsPrintLayout(project)
        layout.initializeDefaults()
        layout.setName(layoutName)
        manager.addLayout(layout)

        #create a map item in the layout
        map=QgsLayoutItemMap(layout)
        map.setRect(20,20,20,20)

        #set the map extent
        ms=QgsMapSettings()
        ms.setLayers([layer1,layer])
        rect=QgsRectangle(ms.fullExtent())
        rect.scale(1)

        ms.setExtent(rect)
        map.setExtent(rect)
        map.setBackgroundColor(QColor(255,255,255,0))
        layout.addLayoutItem(map)

        map.attemptMove(QgsLayoutPoint(5,20,QgsUnitTypes.LayoutMillimeters))
        map.attemptResize(QgsLayoutSize(150,150,QgsUnitTypes.LayoutMillimeters))

        legend = QgsLayoutItemLegend(layout)
        legend.setTitle("Legend")
        layout.addLayoutItem(legend)
        legend.attemptMove(QgsLayoutPoint(230,15,QgsUnitTypes.LayoutMillimeters))

        # scalebar=QgsLayoutItemScaleBar(layout)
        # scalebar.setStyle('Single Box')
        # scalebar.setUnits(QgsUnitTypes.DistanceKilometers)
        # scalebar.applyDefaultSize()
        # scalebar.setNumberOfSegments(3)
        # scalebar.setNumberOfSegmentsLeft(0)
        # scalebar.setUnitsPerSegment(0.5)
        # scalebar.setUnitLabel("Km")
        # scalebar.update()

        '''scalebar.setLinkedMap(map)
        layout.addLayoutItem(scalebar)
        scalebar.attemptMove(QgsLayoutPoint(220,190,QgsUnitTypes.LayoutMillimeters))'''
        scalebar=QgsLayoutItemScaleBar(layout)
        scalebar.setStyle('Single Box')
        scalebar.setUnits(QgsUnitTypes.DistanceKilometers)
        scalebar.setLinkedMap(map)
        scalebar.applyDefaultSize()
        layout.addLayoutItem(scalebar)
        scalebar.attemptMove(QgsLayoutPoint(220,190,QgsUnitTypes.LayoutMillimeters))


        title=QgsLayoutItemLabel(layout)
        title.setText("Décision :" + self.decision)
        title.setFont(QFont('Arial',16))
        layout.addLayoutItem(title)
        title.adjustSizeToText()
        title.attemptMove(QgsLayoutPoint(25,180,QgsUnitTypes.LayoutMillimeters))


        title=QgsLayoutItemLabel(layout)
        title.setText("Carte de Gestion des dérogations au sein A.U.Khemisset 2021 ")
        title.setFont(QFont('Arial',20))
        layout.addLayoutItem(title)
        title.adjustSizeToText()
        title.attemptMove(QgsLayoutPoint(10,10,QgsUnitTypes.LayoutMillimeters))



        fn=str(self.path_name)+"\\"+str(self.name)+"_carte"+".pdf"
        exporter=QgsLayoutExporter(layout)
        exporter.exportToPdf(fn,QgsLayoutExporter.PdfExportSettings())

    def addPoint(self,X,Y):
        self.lista.clear()
        self.listTemp.clear()
    # and
        if  int(self.dlg.lineEdit_3.text()) <= 1000 :
            
            self.path_name= self.dlg.lineEdit_7.text()
            self.name = self.dlg.lineEdit_6.text()
            self.fn=str(self.path_name)+"\\"+str(self.name)+".shp"
            layerFields=QgsFields()
            layerFields.append(QgsField('id',QVariant.Int))
            layerFields.append(QgsField('Value',QVariant.Double))
            layerFields.append(QgsField('name',QVariant.String))
            self.writer=QgsVectorFileWriter(self.fn,'UTF-8',layerFields,QgsWkbTypes.Point,QgsCoordinateReferenceSystem('EPSG:1166'),'ESRI Shapefile')
            feat=QgsFeature()
            feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(X,Y)))
            feat.setAttributes([1,1.1,'my_point'])
            self.writer.addFeature(feat)
            iface.addVectorLayer(self.fn, '', 'ogr')
            #if(self.dlg.checkBox.isChecked()):
                #print("hello world")
            del(self.writer)
            self.createBuffer()
            self.Verify()

            if self.derogation == 1:
                QMessageBox.information(None, "Message d'erreur", "derogation  ! existant")
                self.decision = 'Défavorable: plus de 5 dérogation'
                self.derogation = 0

            
            if self.prive == 1:
                QMessageBox.information(None, "Message d'erreur", "une intersection avec le DOMIANE_PRIVE_ETAT  ! existant")
                self.decision = 'Défavorable: problème d\'intersection avec le DOMIANE_PRIVE_ETAT'
                self.prive = 0

            if self.foret == 1:
                QMessageBox.information(None, "Message d'erreur", "une intersection avec la Forêt existant")
                self.decision = 'Défavorable: problème d\'intersection avec la Forêt'
                self.foret = 0
                
            for j in self.listTemp: 
                for b in j.getFeatures():
                    print(str(b.geometry().area()) + "this is the surface")
                    if int(b.geometry().area() < 10000) :
                        self.surface = 1
                        
            if self.surface == 1:
                QMessageBox.information(None, "Message d'erreur", "une des entitées qui ont une surface moin que 1 héctare ")
                self.decision = 'Défavorable : problème de surface'
                self.surface = 0


            if(len(self.listTemp)!=0):
                self.table_attribute()
            self.export_pdf()
            names = self.dlg.lineEdit_6.text()
            QMessageBox.information(None, "success", "/!\ le projet a été bien creé sous le nom " + names + ".shp " +" \n\n/!\ le buffer a été bien creé sous le nom " + names +"BUFFER.shp " +" \n\n /!\ l'intersection a été bien fait avec les couches sélectionnée "+" \n\n /!\ une carte est bien générée sous le nom " + str(self.name) + "_carte"+".pdf "+" \n\n /!\ toutes les résultats son enregistrées sous le dossier"+"\n " +str(Path(__file__).parent.absolute()))

        elif int(self.dlg.lineEdit_3.text()) > 1000:
            QMessageBox.information(None, "Message d'erreur", "le Buffer choisie n'est pas valable  !")


    def select_output_file(self):
        path = Path(__file__).parent.absolute()
        self.dlg.lineEdit_7.setText(str(path))
    
    def createBuffer(self):
        input = str(Path(__file__).parent.absolute()) +"\\"+ self.name+".shp"
        OutputFile = str(Path(__file__).parent.absolute()) +"\\"+ self.name+"Buffer"+".shp"
        processing.run("native:buffer",{'INPUT':input,'DISTANCE':int(self.dlg.lineEdit_3.text()),'OUTPUT':OutputFile})
        iface.addVectorLayer(OutputFile, '', 'ogr')
        iface.zoomToActiveLayer()
    
    def get_layer_By_Name(self, layerName):
        # layers = QgsProject.instance().layerTreeRoot().children()
            fn = str(Path(__file__).parent.absolute())  + "\\"+ layerName + ".shp"
            layer = QgsVectorLayer(fn,layerName + ".shp", "ogr")
            return layer

    def intersect(self,firstLayer,secondLayer):
        letters = string.ascii_lowercase
        self.name = ''.join(random.choice(letters) for i in range(2))
        fn = str(Path(__file__).parent.absolute()) + "\\"+ secondLayer +"_" + self.name +".shp"
        layer1 = self.get_layer_By_Name(firstLayer)
        layer2 = self.get_layer_By_Name(secondLayer)
        self.val = 0
        for a in layer1.getFeatures():
            for b in layer2.getFeatures():
                if(a.geometry().intersects(b.geometry())):
                    self.val = 1

        if secondLayer == 'DOMIANE_PRIVE_ETAT' :
                for a in layer1.getFeatures():
                    for b in layer2.getFeatures():
                        if(a.geometry().intersects(b.geometry())):
                            self.prive = 1
            
        if secondLayer == 'DOMAINE_FORESTIER' :
            for a in layer1.getFeatures():
                for b in layer2.getFeatures():
                    if(a.geometry().intersects(b.geometry())):
                        self.foret = 1
                
        if self.val == 1 and self.foret == 0 and self.prive == 0:
            parametres={'INPUT':layer1,'OVERLAY':layer2,'INPUT_FIELDS':layer1.fields(),'OVERLAY_FIELDS':layer2.fields(),'OVERLAY_FIELDS_PREFIX':layer1.fields(),'OUTPUT':fn}
            processing.run("qgis:intersection",parametres)
            print(secondLayer + self.name +".shp" + "bb")
            nameTemp = self.name +".shp"
            layer = QgsVectorLayer(fn,secondLayer + nameTemp, "ogr")  
            self.features = layer.getFeatures()
            self.listTemp.append(layer)
            layer_provider=layer.dataProvider()
            layer_provider.addAttributes([QgsField("surface",QVariant.Double)])
            layer.updateFields()
            print (layer.fields().names())
            with edit(layer):
                for feature in layer.getFeatures():
                    print(feature.geometry().area())
                    feature['surface'] = feature.geometry().area()
                    layer.updateFeature(feature)
            # for f in self.features:
            #     id=f.id()
            #     surface2=f.geometry().area()
            #     attr_value={1:surface2}
            #     layer_provider.changeAttributeValues({id:attr_value})
            # layer.commitChanges()
            
            print(fn)
            iface.addVectorLayer(fn , '', 'ogr')


            if secondLayer == 'Derogation_central_13_avril' :
                for i in layer.getFeatures():
                    self.indice = self.indice + 1
                    if self.indice >= 5 :
                        self.derogation = 1
                
            print("My index is" + str(self.indice))

            # for f in self.features:
            #     id=f.id()
            #     length=f.geometry().area()
            #     attr_value={4:length}
            #     layer.changeAttributeValues({id:attr_value})
            #     layer.commitChanges()


            # for feature in layer.getFeatures():
            #     feature["name"] = feature.geometry().area()
            #     layer.updateFeature(feature)
            
    def Verify(self):
        self.listOfLayers.clear()
        
        self.listOfLayers.append("Derogation_central_13_avril")
        self.listOfLayers.append("DOMIANE_PRIVE_ETAT")
        self.listOfLayers.append("DOMAINE_FORESTIER")
        if(self.dlg.checkBox.isChecked()):
            self.listOfLayers.append(self.dlg.checkBox.text())
            print("added"+self.dlg.checkBox.text())
        if(self.dlg.checkBox_3.isChecked()):
            self.listOfLayers.append(self.dlg.checkBox_3.text())
            print("added"+self.dlg.checkBox_3.text())
        if(self.dlg.checkBox_4.isChecked()):
            self.listOfLayers.append(self.dlg.checkBox_4.text())
            print("added"+self.dlg.checkBox_4.text())
        print(self.listOfLayers)

        for i in range(len(self.listOfLayers)):
            print(self.listOfLayers)
            self.intersect(self.dlg.lineEdit_6.text()+"Buffer",self.listOfLayers[i])
            print("done for the ",i)
        

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = projectDialog()
        project = QgsProject.instance()
        projectName = QgsProject.instance().fileName()
        My_list = projectName.split("/")
        name =My_list[len(My_list)-1]
        project.read(name)
        self.layers = [layer for layer in project.mapLayers().values()]
        path = self.dlg.pushButton_2
        path.clicked.connect(lambda: self.select_output_file())
        submit = self.dlg.pushButton
        submit.clicked.connect(lambda: self.addPoint(int(self.dlg.lineEdit_5.text()),int(self.dlg.lineEdit_4.text())))
        self.dlg.comboBox_intersect_layers.currentIndexChanged.connect(lambda: self.setValue())
        self.dlg.btn_Intersection.clicked.connect(lambda: self.export())
        

        #self.dlg.intersect.clicked.connect(lambda: self.Verify())
        #iface.addVectorLayer(fn, '', 'ogr')

        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass